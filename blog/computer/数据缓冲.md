# 数据缓冲区高速缓冲

[TOC]

进程是如何获取文件数据的?

1. 内核将文件数据移以及**辅助信息**移到主存
2. 进程操作该数据
3. 请求将数据保留到文件系统中

> 辅助信息涉及到文件系统中的内容，比如描述文件系统的超级块、描述文件的索引节点等

磁盘的寻址的效率十分低下，如果是内核直接操作磁盘，那么就好比博尔特和乌龟合作，所以需要一个中间过渡--高速缓冲。高速缓冲介于文件系统和设备驱动系统之间。

磁盘块 -->  缓冲区  --> 文件块

高速缓冲通过减小对磁盘的存取频率来提高效率。当读取文件的时候，如果该数据已经在缓冲中，那么就不用读取磁盘；如果不在缓冲区中，那么就从磁盘中读取数据并且暂存到缓冲中。当写入文件的时候，写的数据会被暂存到缓冲中或者是延时写入，以便下一次读取的时候不需要通过磁盘。

> 缓冲机制的设计就是为了数据读写尽可能多的命中缓冲

## 缓冲头部

缓冲区 = 含磁盘上的数据的存储器数组 + 标识缓冲区的缓冲头部

缓冲区是磁盘块在**主存**中的拷贝！

缓冲区数据      	--对应--> 	文件系统上的一个逻辑磁盘块数据 
缓冲头部标识符 	--识别-->	缓冲内容

同一时刻，一个磁盘块只有一个缓冲区！

![缓冲头部](./img/buffer_head.jpg)

- 设备号：并不是物理设备(eg 磁盘)号，而是物理设备通过设备驱动程序映射的逻辑文件系统号
- 块号：标识文件系统分配的文件的号
- 位于散列队列双向链表
- 位于空闲表双向链表

## 缓冲池结构

![](./img/buffer_null_pool.jpg)

**缓冲区空闲表**最近最少使用【不太明白】算法，带有哑节点的双向循环链表，从头部取，往尾部存放。

![散列队列上的缓冲区](./img/buffer_hash_pool.jpg)

之前的图仅仅是缓冲区的空闲链表，上图是所有的缓冲区，空闲链表穿插于上图。一个缓冲区总在某个散列队列上，但是不一定在空闲表中。

## 缓冲区的检索

> 更高的视角：看着看着就会有我到底在做什么的疑惑，那么为什么要获取缓冲区？明确了过程，会更清楚。

一个进程想要读取一个文件，首先判断该文件所在的文件系统，然后确认文件系统中的块号。确定好之后就要读取数据，当然要先看Cache中有没有已经有了，实在不行，只好先申请一个空闲缓冲区，在从磁盘中读取了。

`getblk` 内核把一个缓冲区分配给磁盘块（通过设备号和块号在缓冲池中搜素）可能出现的五种情况：

1. 该块在散列队列中，空闲（该块被自己或者其他进程使用后返回）
2. 该块不在散列队列中，从空闲表中分配一个（该数据块未曾被缓存过）
3. 该块不在散列队列中，试图分配，但是遇到了延时写，内核必须把延迟写缓冲区写到磁盘，并且分配到另一个缓冲区（该数据块未曾被缓冲，找个位置被人占了，重找一个）
4. 该块不在散列队列中，空闲缓冲区用完（该数据块未曾被缓冲，并且当前队列空闲位置用完）
5. 该块在散列队列中，当前忙（该块被自己使用完后，现在被其他进程使用）

### case1

![情况1](./img/case1.jpg)

进程找了的文件所在的文件系统、块号等基本信息，散列到模为0的散列队列表，然后在该队列所指的双向链表中找到了该缓冲区，并且发现是空闲的！所以直接取数据就可以了。但是还要标记该缓冲区为忙！以及从空闲链表中摘下。

### case2

![case2](./img/case2.jpg)

内核在mod为2的队列中没有找到18的缓冲区，就把位于其他队列的空闲链表中的第一个缓冲区放到该队列，并且将该缓冲区的头部该为对应数据。



## 读写磁盘块

#### 读磁盘块

``` C
算法 bread /* 读 块 */
输入：文件系统块号
输出：含有数据的缓冲区
buffer bread(block_num) {
	blk = getblk(block_num);
	if (valid(blk))
		return blk;
	启动磁盘读;
	sleep(等待“读盘完成”事件); //请求后睡眠
	// I/O完成，磁盘中断唤醒当前进程
	return blk;
}
```



## 小结

- 高速缓冲的结构： 散列函数 + 散列队列 + 双向循环链表
- 内核寻找缓冲中磁盘块的方法

## 遗留

不理解最近最少使用算法





